## What software development looks like?

- So, what you will hear or see if you're part of a software development team. 

- Before we get into a software development process, let's take a look at a process that you might be familiar with, like building a house. 

- So, if you were to build a house, you'll probably reach out to a builder and tell about your needs, like, I need two bedrooms, I need a bigger great room, I need a room on the basement, and yada yada yada. 

- And, builders may give you some options, and then you will have to do some analysis, and come back with your choice. 

- In the end of this phase, you will come up with exactly what you're looking for. 

- Then, builder is going to go back, and going to create a floor plan. 

- And then, he's going to show it to you the floor plan, and you might make some adjustment. 

- Once that is done, builder is going to create a detailed map or detailed plan about where the foundation is going to be, where the electricity is going to be, where the plugs are going to be, where the plumbing is going to be, and then, they're going to start building the home. 

- And, as they are building the home, they're going to call the inspection people to come, and inspect the house. 

- For example, let's say the foundation is done, they're going to get the foundation approved. When the plumbing is done, they can get the plumbing approved. And so on. 

- And once the house is ready, he's going to call you to say whether, you like the house, Is it what you expected? And then, once you approve it, then you're going to start, staying in that house or living in that house and, of course, there comes the maintenance of the house. 

- Let's see how software development is similar or different than this. 

- So, when you're building a software, similar to building a house, you're looking at requirements or you're looking at what exactly you need to build. 

- And during that time, you will do analysis of different options or you might do a prototype and show it to your customer, and just say, "Is this what you're looking for?" But at the end of this phase, you have exactly what you're looking to build. 

- Then comes the architects and the software developers. They're going to design the system, they're going to architect the system, and say, what are the different components that they need to build? And how they're going to work together? 

- Once the design is done, they're going to start coding, and start doing unit testing. So, each of the sub-teams are going to start building their components and test it. 

- Once all the components are ready, they're going to bring all of these components together, and do integration testing or card verification. And, they will do functional testing. 

- And when the software is ready from the developer point of view, then they're going to invite the user, and they will do a testing called, UAT, User Acceptance Testing, in which a user says, "Yup, this is what I was looking for." or "No, this is not what I was looking for." 

- And then, once everything is done, then the software goes into production, which means the user is going to start using, and they might ask for some changes, or you may have to fix some defects, and so on. So, that's called the operation and maintenance. 

- So, as you can see, it's quite similar to building a house. The model that we just reviewed is called, a waterfall method, where you go from phase to phase to phase. 

- Requirements, design, implementation. 

- As industries started to use this method, they ran into several issues.

- For example, they found that it's very difficult to predict the requirements one year or two years ahead, as the market changes, or sometimes it's just really difficult to predict what a user will like or not like. 

- And, since the cycle is a year or two years, it is possible that the developers or the architects misinterpreted the requirements. 

- And so, that misinterpretation will go undetected all the way to design, implementation, and the verification. 

- And similarly, the integration issues between the different components, go undetected for a year while the software is being developed. 

- So, as these issues were coming up, other variants for waterfall started to evolve. 

- Like a V-model, which focuses a lot on testing. 

- Or Sashimi model or RUP model, that focuses a lot on overlapping different phases. 

- And then, the incremental model, where you do the requirements in one shot, but then you do the design testing and deployment in increments. 

- And then, there is the Spiral model, which is a very risk-driven approach. 

- As all of these variants were coming along, there was another thought process that were evolving in the software industry, called Agile. 

- So, Agile is not a model. It's a mindset. 

- There were a lot of top leaders in software industry, that were building the software very successfully. And so, they came together and said, "What is it that we are doing that is making us successful?" 

- And they articulated what we call now the Agile Manifesto and Principles. 

- And, as this manifesto and principles were crafted, there were models like Scrum, and Kanban, and XP, that helped implement this mindset, that promote this mindset. 

- And so, you can see it's not just these three, but many other models came to be. 

- The basic idea behind all of this model, was that instead of building this whole one year cycle, you build in short cycles. 

- So, you define little, you build, you test, and you learn. And then again, you just keep doing this. That way you can adjust to the market quickly. And then, you are learning from your users quickly. 

- And so, the change became a norm, because after every cycle you may have a change. 

- And, software industry also has to learn how to respond to this change quickly and confidently. 

- And, the idea of continuous integration, where a developer who is building the code, as soon as he commits the code or has soon as he finishes the code, it's integrated with all the other components of that software. 

- And then, all the tests that verify whether the system is running. They're called, the automated testing. So, as soon as you commit the code, all of the test is tested, to make sure nothing else is broken in the system. And, all of this deployment is automated. 

- So, as soon as the code is committed, it's deployed automatically so that there is no manual errors, as well as it reduces the effort to deploy a code. 

- And not only just these three, many other practices evolved. 

- And so, the safety net of automated testing, and this automation, help developers respond quickly and confidently to the changes. 

- This also led to a new partnership between the developers and the operations. 

- They march towards a common goal. And, that led to a culture of DevOps. 

- Now, as this model of Agile was getting popular in industry in a smaller scale, people started to wonder, "Can we apply this on bigger projects?" 

- And hence, many new models evolve, like Scale Agile Framework, Large Scale Scrum, and Disciplined Agile Framework. Sounds complicated, and they are. 

- And, many organizations are trying to use these models and are successful. But the jury's still out there around the effectiveness of these models. 

- So, from one-year to two-year life cycles, the industry moved to smaller cycles. But then, they wanted to learn if there is a cheaper and a faster way to learn. 

- And, the concepts like Lean Startup and Design Thinking came into being, where, you find the cheapest way to learn the one cycle. 

- An example is zappos.com. They wanted to sell shoes online. And since this was a new concept, they didn't know if somebody is going to buy shoes online. 

- And so, instead of building a whole new infrastructure of inventory of shoes, they just created a website, and said, "Let's see if people buy. If people will buy, I'll go to a store, buy the shoe, and then ship it to the customer." 

- And they did it, and they were successful. And then, they started adding infrastructure. 

- So, the same concept that was applicable in startup, started to evolve and be adopted in the enterprise as well. 

- And, this also led to team members or the organization to focus on the outcome and not just the output that they are building. 

- And, as all of these process and methodologies were evolving, industry also realized that process is just a part of the puzzle. 

- We have to think about some soft issues, like psychological safety or motivations of the individuals, and growth mindset, and many other concepts like this. 

- So, as you can see, software industry has evolved quite a bit in last several years, and it's continuing to get better and better.


## Questions and answers
1. Which of the following software development models can best respond to requirements changes? Agile models

2. In which of the following software development models are the software development activities performed sequentially rather than in iterations? The Waterfall model

3. Which of the following are limitations of the waterfall model?  Select three.
    1. Misinterpretations of requirements or design can remain undetected until the later development phases.
    3. Integration issues may remain undetected until the last phase.
    4. It is difficult to respond to requirements changes.